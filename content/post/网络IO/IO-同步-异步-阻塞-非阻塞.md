---
title: "IO 同步 异步 阻塞 非阻塞"
date: 2021-04-25T16:30:42+08:00
categories:
- 网络IO
tags:
- IO模型
keywords:
- tech
#thumbnailImage: //example.com/image.jpg
---
　　Linux网络IO模型
<!--more-->
对一个网络IO（以read为例），会涉及两个系统对象：调用这个IO的进程和系统内核，当read发生时，会经历两个阶段：
1. 等待数据准备
2. 将数据从内核拷贝到进程中

不同IO模型的区别主要就表现在这两个阶段的不同。

# 阻塞IO
Linux下默认所有的socket都是阻塞的，一个阻塞的read的工作流程大概如下图示：
![阻塞IO模型](/网络IO/IO同步/1.png)

当用户进程调用了recvfrom这个系统调用，内核就开始IO的第一阶段：准备数据，对于网络IO来说，很多时候数据在一开始还未到达，内核就会等待足够的数据到达，在用户进程这边，整个进程会被阻塞，当数据准备好了，内核会将数据从内核拷贝到用户进程内存，之后返回结果，此时用户进程接触阻塞状态，重新开始运行。

# 非阻塞IO
一个非阻塞的read的工作流程大概如下图示：
![非阻塞IO模型](/网络IO/IO同步/2.png)

当用户进程调用recvfrom，若内核中数据未准备好，那么它会立刻返回一个error，用户进程相应得到一个结果，用户进程判断错误为数据为准备好，于是再次发送recvfrom操作，一旦内核中数据准备好了，且再次收到用户进程的系统调用，它就会将数据拷贝到用户进程内存，然后返回（拷贝数据的过程用户进程为阻塞的）。

# IO多路复用（事件驱动IO）
select/epoll可以同时处理多个网络IO连接，它的基本原理是轮询所负责的socket，当某个socket有数据到达，就通知用户进程，如下图示：

![IO多路复用](/网络IO/IO同步/3.png)

当用户进程调用select，整个进程会被阻塞，同时内核监听所有select负责的socket，当任何一个socket中数据准备好了，select就会返回，此时用户进程在调用recvfrom将数据拷贝到用户进程内存。

需要注意的是，如果连接数不是很多，使用select/epoll不一定比使用多线程加阻塞IO性能好，select/epoll的优势并不是对于单个连接处理得更快，而是能处理更多的连接。

在IO多路复用中，对每一个socket，一般都设置为非阻塞的。

# 异步IO
工作流程如下图示：
![异步IO模型](/网络IO/IO同步/4.png)

当用户发起recvfrom后内核就立刻返回，不会对用户进程产生任何阻塞，然后内核等待数据准备完成后将其拷贝到用户进程内存，并通知用户进程recvfrom操作完成。

# 同步IO和异步IO的区别
两者的区别主要是同步IO在执行IO操作时会将用户进程阻塞，因此阻塞IO、非阻塞IO（非阻塞IO在执行数据拷贝时会阻塞用户进程）和IO多路复用都属于同步IO；而异步IO在用户进程发起IO操作后就再也不管了，直到内核发送一个完成信号，在这一过程中用户进程完全没有被阻塞。

# 参考
- [IO - 同步，异步，阻塞，非阻塞](https://blog.csdn.net/historyasamirror/article/details/5778378)
