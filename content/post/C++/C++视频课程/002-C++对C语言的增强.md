---
title: "002-C++对C语言的增强"
date: 2020-06-17T23:27:46+08:00
categories:
- C++
- C++视频课程
tags:
- C++基础
keywords:
- tech
#thumbnailImage: //example.com/image.jpg
---

<!--more-->
### 命名空间

　　C语言只有一个全局作用域，C++提出了命名空间将全局作用域分为不同的部分，不同命名空间的标识符可以同名而不发生冲突。

　　用法：
      1. using 命名空间::变量名　　
      2. using namespace 命名空间

### 实用性增强

　　C语言的变量需要在作用域开始的位置定义，即需要在所有语句的前面定义，C++为了提高语言的实用性，变量可以在需要使用的位置定义。

### register变量增强

　　C语言为了提高变量存取速度，用register关键字请求将变量放在寄存器中，但是不能取寄存器变量的地址，C++对register关键字做了优化，不使用register关键字也可能将变量放在寄存器中，比如在频繁使用变量的情况下，C++编译器会将变量放在寄存器中，比如for循环中的循环变量，且C++中可以对register变量取地址（编译器发现需要对register变量取地址时，register对变量的声明变得无效）。

### 变量检测增强

　　C语言中直接定义多个同名的全局变量是合法的，而C++中则不可以，C语言多个同名的全局变量会被链接到全局数据区中的同一个地址空间上。

### struct关键字增强

　　C语言中struct关键字仅仅是定义了一组变量的集合，并不是一种新的类型，定义变量时需要明确写上struct，C++中struct可以定义新的类型。

### 类型检查增强

　　C语言允许变量和函数有默认类型，而C++中所有变量和函数必须有类型。

### 表达式增强

　　C语言表达式的运算结果是变量的值，放在寄存器里，不能做左值，而C++中表达式作为左值时返回变量本身（即内存空间中变量的地址），比如三目运算符在C语言中不能作为左值，而C++中则可以，C语言实现C++三目运算符：

```cpp
*(a < b ? &a : &b) = 30;
```

### const变量增强

　　C语言中const变量的值可以通过取地址间接修改，C++中则不可以，因为C++将const变量放在一个符号表中，其中是一个个的键值对，当对常量取地址的时候，会为其新开一个内存空间，因此通过地址间接修改的不是原来的常量的值。

　　C语言中const变量是只读变量，有自己的内存空间，C++中const变量可能分配内存空间（1. const变量为全局变量且需要被其它文件使用 2. 对const变量取地址），也可能不分配内存空间，分配内存会在编译器编译期间进行。

### 引用

　　引用是变量的别名，普通引用在声明时必须用其它变量进行初始化，引用作为其它变量的别名，因此在某些场合可以替代指针。

　　引用的本质：1.单独定义引用时必须初始化，说明引用很像一个常量；2.引用跟原变量是同一块内存空间的别名，普通引用有自己的内存空间，大小与指针所占大小一样；因此可以知道引用在C++内部是一个常指针：`T &name == T *const name`，为什么不是const T*呢？因为可以通过引用变量修改原变量的值且引用赋值后不能再引用别的变量。

### 函数返回值是引用（基础类型）

　　当函数返回值是引用时，若返回局部变量（栈上），不能作为其它引用的初始值，不能作为左值使用，但是返回静态变量或全局变量时可以作为其它引用的初始值，既可作为右值使用，又可作为左值使用。函数返回值是引用的时候，函数也可以当左值。

### C++内存分布

　　C++中内存分为栈区、堆区，全局变量区和代码区，函数体中定义的变量的内存，new或malloc申请的内存空间在堆区中。
![内存分布](/C++视频课程/002/内存分布.jpg)

### 常引用

　　 若不想通过引用修改变量的值，需要定义常引用，让引用拥有只读属性。

　　常引用的初始化分为两种：

1. 用变量初始化
2. 用字面量初始化

　　普通引用不能引用字面量，因为字面量没有内存空间，无法取别名。

### 内联函数

　　C++可以用const常量替代宏常量，那么是否可以替代宏代码片段呢？

　　有！内联函数！

　　内联函数的声明和定义必须写在一起，c++编译器在编译时直接用内联函数的函数体替换掉函数的调用，因此内联函数没有普通函数调用时额外的开销（压栈、跳转、返回等）；内联函数是一种特殊的函数，具有普通函数的特征（参数检查、返回类型等），它是对编译器的一种请求，因此编译器可能会拒绝这种请求。

　　内联函数和宏代码片段有什么不同？

　　内联函数是由编译器处理的，直接将函数体插入函数调用的地方，而宏代码片段是由预处理器处理的，只进行简单的文本替换，不进行任何编译处理。C++编译器会进行编译优化，有些函数即使没有内联声明，也可能被编译器内联编译。

　　内联函数需要注意：

1. 不能存在任何循环语句
2. 不能存在过多的条件判断或switch语句
3. 函数体不能过大
4. 不能取函数的地址
5. 声明必须在调用之前

　　当函数体的执行开销远大于压栈、跳转和返回等开销时，不应使用内联函数，因为每一处内联函数的调用都会复制代码，使程序的总代码量增大，消耗更多内存空间。
![宏定义的坑](/C++视频课程/002/宏定义的坑.jpg)

### 占位参数

　　函数占位参数在函数调用时必须传入实参，占位参数可以和默认参数结合使用`void fun(int a, int = 0)`，此时传入一个参数和两个参数都可以。

### 函数重载

　　函数重载至少需要满足以下几个条件之一：

1. 参数个数不同
2. 参数类型不同
3. 参数顺序不同

　　函数返回值类型不是函数重载的判断标准。

　　默认参数会影响函数重载。

### 函数指针

　　定义函数指针变量的几种方法：

1. 声明一个函数类型：`typedef void (Func)(int a);`，通过声明的函数类型可以定义函数指针变量，指向函数的入口地址：`Func *funcp = NULL;`
2. 直接声明一个函数指针类型：`typedef void(*FuncP)(int a);`，通过声明的函数指针类型可以定义一个函数指针变量：`FuncP funcp = NULL;`
3. 直接定义一个函数指针变量：`void (*funcp)(int a)`

　　把重载函数名赋值给函数指针变量，之后通过函数指针调用函数时会执行严格的参数个数和参数类型的匹配。
