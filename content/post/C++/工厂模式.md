---
title: "工厂模式"
date: 2020-08-10T16:09:59+08:00
categories:
- C++
tags:
- 工厂模式
keywords:
- tech
#thumbnailImage: //example.com/image.jpg
---
[参考链接](https://juejin.im/post/6844903942170607623)
<!--more-->
# C++工厂模式

## 1 概述
　　工厂模式属于创建型设计模式，提供了一种创建对象的最佳方式，工厂模式中创建对象时不会对客户暴露创建逻辑，且通过一个共同的接口指向新创建的对象。

　　工厂模式的实现方式可以分为**简单工厂模式**、**工厂方法模式**、**抽象工厂模式**。

　　下面已生产鞋子的工厂为例子介绍这几种模式。

## 2 简单工厂模式
　　假设有一个鞋厂可以生产耐克、阿迪达斯和李宁的鞋子，鞋厂的老板根据销量决定生产哪个，如下图：
![简单工厂模式](/C++/工厂模式/简单工厂模式.jpg)

　　组成结构：
1. 工厂类(ShoesFactory)：工厂模式的核心类，定义了创建具体实例对象的接口。
2. 抽象产品类(Shoes)：具体产品类的继承父类。
3. 具体产品类(NikeShoes\AdidasShoes\LiNingShoes)：工厂类创建的对象类。

　　特点：
- 封装了创建具体产品对象的函数。

　　缺点：
- 扩展性差，新增产品的时候，需要去修改工厂类。

　　实现：
```cpp
#include <iostream>

class Shoes {
 public:
  virtual void Show() = 0;
  virtual ~Shoes() {}
};

class NikeShoes : public Shoes {
 public:
  void Show() { std::cout << "Nike Shoes!" << std::endl; }
};

class AdidasShoes : public Shoes {
 public:
  void Show() { std::cout << "Adidas Shoes!" << std::endl; }
};

class LiNingShoes : public Shoes {
 public:
  void Show() { std::cout << "LiNing Shoes!" << std::endl; }
};

enum SHOES_TYPE { NIKE, ADIDAS, LINING };

class ShoesFactory {
 public:
  Shoes *CreateShoes(SHOES_TYPE type) {
    switch (type) {
      case NIKE:
        return new NikeShoes();
        break;
      case ADIDAS:
        return new AdidasShoes();
        break;
      case LINING:
        return new LiNingShoes();
        break;
      default:
        return NULL;
        break;
    }
  }
};

int main() {
  ShoesFactory shoes_factory;
  Shoes *pNikeShoes = shoes_factory.CreateShoes(NIKE);
  if (pNikeShoes != NULL) {
    pNikeShoes->Show();
    delete pNikeShoes;
    pNikeShoes = NULL;
  }
  Shoes *pLiNingShoes = shoes_factory.CreateShoes(LINING);
  if (pLiNingShoes != NULL) {
    pLiNingShoes->Show();
    delete pNikeShoes;
  }

  return 0;
}
```

　　为什么要写虚拟构函数？
[虚拟构函数](https://blog.csdn.net/starlee/article/details/619827)

## 3 工厂方法模式
　　若市场上每个牌子的鞋子都销量很好，需要大量生产各个牌子的鞋子，则需要针对不同品牌开设独立的生产线，每个生产线只生产一个品牌的鞋子。
![工厂方法模式](/C++/工厂模式/工厂方法模式.jpg)

　　组成结构：
1. 抽象工厂类(ShoesFactory)：工厂方法模式的核心类，提供创建具体产品的接口，由具体工厂类实现。
2. 具体工厂类(NikeProducter\AdidasProducter\LiNingProducter)：继承自抽象工厂类，实现创建具体产品实例的方法。
3. 抽象产品类(Shoes)：具体产品类的继承父类。
4. 具体产品类(NikeShoes\AdidasShoes\LiNingShoes)：具体工厂类创建的对象类。

　　特点：
- 抽象出了工厂类，提供创建具体产品的接口，交由子类去实现
- 将具体对象的创建放到具体工厂类实现

　　缺点：
- 每新增一个产品，就需要增加一个具体工厂类
- 一条产品线只能生产一个产品

　　实现：
```cpp
#include <iostream>

class Shoes {
 public:
  virtual void Show() = 0;
  virtual ~Shoes() {}
};

class NikeShoes : public Shoes {
 public:
  void Show() { std::cout << "Nike Shoes!" << std::endl; }
};

class AdidasShoes : public Shoes {
 public:
  void Show() { std::cout << "Adidas Shoes!" << std::endl; }
};

class LiNingShoes : public Shoes {
 public:
  void Show() { std::cout << "LiNing Shoes!" << std::endl; }
};

class ShoesFactory {
 public:
  virtual Shoes *CreateShoes() = 0;
  virtual ~ShoesFactory() {}
};

class NikeProducter : public ShoesFactory {
 public:
  Shoes *CreateShoes() { return new NikeShoes(); }
};

class AdidasProducter : public ShoesFactory {
 public:
  Shoes *CreateShoes() { return new AdidasShoes(); }
};

class LiNingProducter : public ShoesFactory {
 public:
  Shoes *CreateShoes() { return new LiNingShoes(); }
};

int main() {
  ShoesFactory *nike_productor = new NikeProducter();
  Shoes *nike_shoes = nike_productor->CreateShoes();
  nike_shoes->Show();
  delete nike_shoes;
  delete nike_productor;

  return 0;
}
```

## 4 抽象工厂模式
　　若工厂扩大业务，除了生产鞋子，也生产衣服。
![抽象工厂模式](/C++/工厂模式/抽象工厂模式.jpg)

　　组成结构：
1. 