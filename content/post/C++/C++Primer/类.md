---
title: "类"
date: 2021-05-18T11:01:11+08:00
categories:
- C++
- C++Primer
tags:
- 类
keywords:
- tech
#thumbnailImage: //example.com/image.jpg
---
类的设计
<!--more-->
# 1. 类的基础知识
类的基本思想是**数据抽象**和**封装**，数据抽象是一种依赖于**接口**和**实现**分离的编程技术，接口包括用户所能执行的操作，实现包括类的数据成员、负责接口实现的函数体以及定义类所需要的各种私有函数；封装后的类隐藏了实现细节，类的用户只能使用接口而无法访问实现部分。

## 1.1 this指针
成员函数通过一个名为`this`的隐式参数来访问调用它的对象，当类的实例化对象调用一个成员函数时，用该对象的地址初始化`this`，可以等价地认为编译器将成员函数的调用重写为如下形式：
```cpp
total.isbn();
// 等价形式，用于说明调用成员函数的实际执行过程
Sales_data::isbn(&total);
```

在成员函数内部可以直接调用类的成员，也可以显示使用this（没必要），例如：
```cpp
std::string isbn() const {
  // return bookNo;
  return this->bookNo;
}
```

## 1.2 const成员函数
如`isbn()`函数参数列表之后的`const`关键字，其作用是修改`this`指针的类型，默认情况下，`this`指针的类型是指向类类型的**非常量版本的常量指针**，例如在`Sales_data`成员函数中，`this`的类型是`Sales_data *const`，遵循初始化规则，`this`指针不能绑定到一个常量对象上，即不能在一个常量对象上调用普通的成员函数，因此有时候为了提高函数的灵活性会将`this`声明为指向常量的指针，而`this`是隐式的，并不会出现在参数列表中，所以将`const`放在参数列表后，使用`const`的成员函数被称作**常量成员函数**。
```cpp
// isbn函数的伪代码，用来说明this指针的用法
std::string Sales_data::isbn(const Sales_data *const this) {
  return this->bookNo;
}
```

> 常量对象及常量对象的引用或指针都只能调用常量成员函数

## 1.3 编译器对类成员的处理
编译器分两步处理类：
1. 编译成员的声明
2. 编译成员函数体

因此，成员函数体可以随意使用类中的其它成员而无需在意这些成员出现的次序。

## 1.4 类外部定义成员函数
当在类外部定义成员函数时，成员函数的定义必须与它的声明匹配，也就是说**返回类型、参数列表和函数名**都要与类内部的声明一致，同时函数名前需要**指定类名作用域**，常量成员函数在类外部定义时也需要在参数列表后指定`const`属性。

## 1.5 返回this对象的成员函数
模拟复合赋值运算符`+=`，`Sales_data`类的成员函数`combine`需要返回引用类型，如下：
```cpp
Sales_data& Sales_data::combine(const Sales_data &rhs) {
  units_sold += rhs.units_sold;
  revenue += rhs.revenue;
  return *this; // 返回total的引用
}

total.combine(trans); // total地址被绑定到隐式this，rhs绑定到trans
```

返回引用的函数是左值的，意味着这些函数返回的是对象的本身而非对象的副本，可以将这样的操作连接在一条表达式中，这些操作将在同一个对象上执行。

## 1.6 从const成员函数返回*this
若成员函数为`const`成员，那么`this`指针是一个指向`const`对象的常量指针，那么`*this`是`const`对象，`const`成员函数的返回类型为`const Sales_data&`，注意不能与返回普通引用的成员函数连接使用。

> 一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用

## 1.7 基于const的重载
成员函数可以通过`const`进行重载，因为`this`指针也是函数参数，尽管是默认的；非常量版本的函数对常量对象是不可用的，虽然可以在非常量对象上调用常量版本或非常量版本，显然非常量版本更加匹配。

#### 1.7.1 对公共代码使用私有函数功能
假设有一个`Screen`类，其中接口`set`负责设置光标位置的字符，接口`move`负责移动屏幕光标，如下：
```cpp
class Screen {
public:
  typedef std::string::size_type pos;
  Screen() = default;
  Screen(pos ht, pos wd, char c) : height(ht), width(wd), contents(ht * wd, c) {}
  Screen &set(char c);
  Screen &move(pos r, pos c);
private:
  pos cursor = 0, height = 0, width = 0;
  std::string contents;
}
inline Screen& Screen::set(char c) {
  contents[cursor] = c;
  return *this;
}
inline Screen& Screen::move(pos r, pos c) {
  pos row = r * width;
  cursor = row + c;
  return *this;
};
```

若继续添加一个名为`display`的接口用于打印`Screen`的内容，逻辑上来说`display`并不需要改变它的内容，因此令其为`const`成员，而又希望其与`set`和`move`接口连接使用，因此定义一个名为`do_display`的私有函数，由它负责实际的打印工作，`display`操作调用这个函数，然后返回执行操作的对象：
```cpp
class Screen {
public:
  // 根据对象是否是const重载了display函数
  Screen &display(std::ostream &os) {
    do_display(os);
    return *this;
  }
  const Screen &display(std::ostream &os) const {
    do_display(os);
    return *this;
  }
private:
  void do_display(std::ostream &os) const {
    os << contents;
  }
};
```

当对象调用`display`时，该对象是否是`const`决定了该调用哪个版本。

## 1.8 类相关的非成员函数
类通常需要定义一些辅助函数，它们概念上来说属于类的接口部分，但它们并不属于类本身，这些函数的声明应与类在同一个头文件中，这样，类的用户在使用类的接口时只需要引入一个头文件。

例如`Sales_data`类的`read`函数：
```cpp
istream &read(istream &is, Sales_data &item) {
  double price;
  is >> item.bookNo >> item.units_sold >> price;
  item.revenue = price * item.units_sold;
  return is;
}
```

这个函数从给定流中将数据读到给定对象里，函数接受一个`IO`类型的引用作为其参数，这是因为`IO`类属于不能被拷贝的类型，只能通过引用来传递，且读取操作会改变流的内容，使用的是普通引用。

## 1.9 构造函数
构造函数不能被声明成`const`的，当创建一个`const`对象时，直到构造函数完成初始化过程，对象才能真正取得其常量属性，因此，构造函数可以在`const`对象的构造过程中向其写值。

### 1.9.1 合成的默认构造函数
若类没有显示定义构造函数，编译器会隐式定义一个默认构造函数，其按如下规则初始化类的数据成员：
1. 若存在类内初始值，使用类内初始值初始化数据成员，C++11标准规定可以为数据成员提供一个**类内初始值**，创建对象时，类内初始值用于初始化数据成员，类内初始值可以放在花括号里或放在等号右边，但是不能使用圆括号
2. 否则，默认初始化该成员

默认构造函数无需任何实参。

> 只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数

某些情况下合成的默认构造函数可能执行错误的操作，定义在块作用域中的内置类型或复合类型（数组或指针）的对象执行默认初始化的值将是未定义的，因此，含有内置类型或复合类型成员的类应在类内部初始化这些成员或定义一个自己的默认构造函数，否则用户在创建类对象时就可能得到未定义的值。

> 若类包含内置类型或复合类型的成员，则只有当这些成员全都被赋予了类内初始值时，这个类才适合于使用合成的默认构造函数

注意某些情况下编译器不能为类合成默认构造函数，例如类中包含一个其它类类型的成员且这个成员的类型没有默认构造函数。

### 1.9.2 =default的含义
一般来说定义这个构造函数的目的是因为既需要其他形式的构造函数，也需要默认的构造函数，且希望这个函数的作用完全等同于合成默认构造函数，通过在参数列表后面写上`= default`来要求编译器生成构造函数。

注意，若编译器不支持类内初始值，那么默认构造函数就应该使用构造函数初始化列表来初始化成员。

## 1.10 拷贝、赋值和析构
除了控制类的初始化之外，还需要控制拷贝、赋值和销毁对象时的行为；对象在初始化变量及以值的方式传递或返回一个对象等情况下会被拷贝，当使用赋值运算符时会发生对象的赋值操作，当对象生命周期结束时会执行销毁操作；和构造函数一样，若不主动定义这些操作，编译器将会生成默认的版本，编译器生成的版本将对对象的每个成员执行拷贝、赋值和销毁操作。

注意当类需要分配类对象之外的资源时，合成的版本无法正常工作，即管理动态内存的类通常不能依赖于合成的版本，不过很多需要动态内存的类可以（应该）通过`vector`或`string`对象管理必要的存储空间，使用他们能避免分配和释放内存带来的复杂性，即若类包含`vector`或`string`成员，则其拷贝、赋值和销毁的合成版本能够正常工作。

## 1.11 类型成员
除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名，称为**类型成员**，与其它成员一样存在访问限制，与普通成员不同的是类型成员必须先定义后使用，因此，类型成员通常出现在类开始的地方。

## 1.12 内联成员函数
定义在类内部的成员是自动`inline`的，还可以在类内部把`inline`作为声明的一部分显示地声明成员函数或在类的外部用`inline`修饰函数的定义，不过建议只在类外部定义的地方说明`inline`，这样可以使类更容易理解。

`inline`成员函数应该与相应的类定义在同一个头文件中。

## 1.13 mutable可变数据成员
有时希望能够修改类的某个数据成员，即使在一个const成员函数内，通过在变量声明中加入`mutable`关键字可以使`const`成员函数修改这一变量。

## 1.14 类类型
每个类定义了唯一的类型，对两个类来说，即使他们的成员完全一样，这两个类也是不同的类型，类名即为类型的名字。

## 1.15 类的声明
仅仅声明类而暂时不定义它的行为称为**前向声明**，它向程序中引入类名字且指明该名字是一种类类型，在定义之前，它是一个不完全类型，只能在有限的情景下使用：定义指向这种类型的指针或引用，也可以声明（但不能定义）以不完全类型作为参数或返回类型的函数。


# 2. 类的访问控制与封装
访问控制是对类的实现进行封装，C++中使用**访问说明符**加强类的封装性：
- 定义在`public`说明符之后的成员在整个程序内可被访问，`public`成员定义类的接口
- 定义在`private`说明符之后的成员可被类的成员函数访问，但不能被使用该类的代码访问，`private`说明符部分封装了类的实现细节

## 2.1 class和struct关键字
都可以定义类，唯一的区别是`struct`和`class`的默认访问权限不一样，类可以在它的第一个访问说明符之前定义成员，若定义类时使用`struct`关键字，则定义在第一个访问说明符之前的成员是`public`的，相反，若使用`class`关键字，这些成员是`private`的。

## 2.2 友元
若某些类相关的非成员函数需要使用类的私有成员，尽管它们是类接口的一部分，但它们不是类的成员，C++中类允许其他类或函数访问它的非公有成员，方法是令其它类或函数成为它的**友元**，即在声明前加上`friend`关键字。

友元的声明只能出现在类定义的内部，不受它所在区域访问控制级别的约束，一般来说，最好在类定义开始或结束前的位置集中声明友元。

注意友元的声明仅仅指定了访问的权限而非一个通常意义上的函数声明，需要在友元声明之外再专门对友元函数进行一次声明，通常把友元函数的声明与类放置在同一个头文件中。

> 除了普通函数，类还可以把其它类或其它类的成员函数定义为友元。

### 2.2.1 类之间的友元关系
假设有一个窗口管理类`Window_mgr`类负责管理`Screen`类，其包含一个`Screen`类型的`vector`：
```cpp
class Window_mgr {
private:
  // 默认情况下，包含一个标准尺寸的空白Screen
  std::vector<Screen> screens{Screen(24, 80, ' ')};
};
```

若`Window_mgr`类有一个`clear`接口负责把一个指定`Screen`的内容清空，那么`clear`需要访问`Screen`的私有成员，即`Screen`需要把`Window_mgr`指定为它的友元：
```cpp
class Screen {
  // Window_mgr的成员可以访问Screen的私有部分
  friend class Window_mgr;
};
```

那么`clear`可以写为如下形式：
```cpp
class Window_mgr {
public:
  // 窗口每个屏幕的编号
  using ScreenIndex = std::vector<Screen>::size_type;
  void clear(ScreenIndex);
private:
  std::vector<Screen> screens{Screen(24, 80, ' ')};
}
void Window_mgr::clear(ScrrenIndex i) {
  Screen &s = screens[i];
  s.contents = string(s.height * s.width, ' ');
};
```

> 每个类负责控制自己的友元类或友元函数，即友元关系不存在传递性，即`Window_mgr`的友元不能理所当然地具有访问`Screen`的特权

### 2.2.2 令成员函数作为友元
上例中还可以只为`clear`提供访问权限，当把一个成员函数声明为友元时，必须明确指出该成员函数属于哪个类：
```cpp
class Screen {
  //Window_mgr::clear必须在Screen类之前被声明
  friend void Window_mgr::clear(ScreenIndex);
}
```

要令某个成员函数作为友元，必须仔细组织程序结构以满足声明和定义的彼此依赖关系：
1. 首先定义`Window_mgr`类，声明`clear`函数，但**不能定义它**
2. 定义`Screen`类，包括对`clear`的友元声明
3. 定义`clear`，此时它才可以使用`Screen`的成员

### 2.2.3 函数重载和友元
尽管重载函数的名字相同，但它们仍是不同的函数，因此，一个类想把一组重载函数声明为它的友元，需要对这组函数中的每一个分别声明。

### 2.2.4 友元声明和作用域
类和非成员函数的声明不是必须在它们的友元声明之前，当一个名字第一次出现在一个友元声明时，隐式地假设该名字在当前作用域中是可见的（然而，友元本身不一定真的声明在当前作用域中），就算在类内部定义友元函数，也必须在类外部提供相应的声明从而使得函数可见，否则无法使用该函数。
```cpp

```
