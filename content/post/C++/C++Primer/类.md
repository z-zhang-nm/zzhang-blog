---
title: "类"
date: 2021-05-18T11:01:11+08:00
categories:
- C++
- C++Primer
tags:
- 类
keywords:
- tech
#thumbnailImage: //example.com/image.jpg
---
类的设计
<!--more-->
# 1. 类知识全家桶
类的基本思想是**数据抽象**和**封装**，数据抽象是一种依赖于**接口**和**实现**分离的编程技术，接口包括用户所能执行的操作，实现包括类的数据成员、负责接口实现的函数体以及定义类所需要的各种私有函数；封装后的类隐藏了实现细节，类的用户只能使用接口而无法访问实现部分。

## 1.1 this指针
成员函数通过一个名为`this`的隐式参数来访问调用它的对象，当类的实例化对象调用一个成员函数时，用该对象的地址初始化`this`，可以等价地认为编译器将成员函数的调用重写为如下形式：
```cpp
total.isbn();
// 等价形式，用于说明调用成员函数的实际执行过程
Sales_data::isbn(&total);
```

在成员函数内部可以直接调用类的成员，也可以显示使用this（没必要），例如：
```cpp
std::string isbn() const {
  // return bookNo;
  return this->bookNo;
}
```

## 1.2 const成员函数
如`isbn()`函数参数列表之后的`const`关键字，其作用是修改`this`指针的类型，默认情况下，`this`指针的类型是指向类类型的**非常量版本的常量指针**，例如在`Sales_data`成员函数中，`this`的类型是`Sales_data *const`，遵循初始化规则，`this`指针不能绑定到一个常量对象上，即不能在一个常量对象上调用普通的成员函数，因此有时候为了提高函数的灵活性会将`this`声明为指向常量的指针，而`this`是隐式的，并不会出现在参数列表中，所以将`const`放在参数列表后，使用`const`的成员函数被称作**常量成员函数**。
```cpp
// isbn函数的伪代码，用来说明this指针的用法
std::string Sales_data::isbn(const Sales_data *const this) {
  return this->bookNo;
}
```

> 常量对象及常量对象的引用或指针都只能调用常量成员函数

## 1.3 编译器对类成员的处理
编译器分两步处理类：
1. 编译成员的声明
2. 编译成员函数体

因此，成员函数体可以随意使用类中的其它成员而无需在意这些成员出现的次序。

## 1.4 类外部定义成员函数
当在类外部定义成员函数时，成员函数的定义必须与它的声明匹配，也就是说**返回类型、参数列表和函数名**都要与类内部的声明一致，同时函数名前需要**指定类名作用域**，常量成员函数在类外部定义时也需要在参数列表后指定`const`属性。

## 1.5 返回this对象的成员函数
模拟复合赋值运算符`+=`，`Sales_data`类的成员函数`combine`需要返回引用类型，如下：
```cpp
Sales_data& Sales_data::combine(const Sales_data &rhs) {
  units_sold += rhs.units_sold;
  revenue += rhs.revenue;
  return *this; // 返回total的引用
}

total.combine(trans); // total地址被绑定到隐式this，rhs绑定到trans
```

返回引用的函数是左值的，意味着这些函数返回的是对象的本身而非对象的副本，可以将这样的操作连接在一条表达式中，这些操作将在同一个对象上执行。

## 1.6 从const成员函数返回*this
若成员函数为`const`成员，那么`this`指针是一个指向`const`对象的常量指针，那么`*this`是`const`对象，`const`成员函数的返回类型为`const Sales_data&`，注意不能与返回普通引用的成员函数连接使用。

> 一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用

## 1.7 基于const的重载
成员函数可以通过`const`进行重载，因为`this`指针也是函数参数，尽管是默认的；非常量版本的函数对常量对象是不可用的，虽然可以在非常量对象上调用常量版本或非常量版本，显然非常量版本更加匹配。

#### 1.7.1 对公共代码使用私有函数功能
假设有一个`Screen`类，其中接口`set`负责设置光标位置的字符，接口`move`负责移动屏幕光标，如下：
```cpp
class Screen {
public:
  typedef std::string::size_type pos;
  Screen() = default;
  Screen(pos ht, pos wd, char c) : height(ht), width(wd), contents(ht * wd, c) {}
  Screen &set(char c);
  Screen &move(pos r, pos c);
private:
  pos cursor = 0, height = 0, width = 0;
  std::string contents;
}
inline Screen& Screen::set(char c) {
  contents[cursor] = c;
  return *this;
}
inline Screen& Screen::move(pos r, pos c) {
  pos row = r * width;
  cursor = row + c;
  return *this;
};
```

若继续添加一个名为`display`的接口用于打印`Screen`的内容，逻辑上来说`display`并不需要改变它的内容，因此令其为`const`成员，而又希望其与`set`和`move`接口连接使用，因此定义一个名为`do_display`的私有函数，由它负责实际的打印工作，`display`操作调用这个函数，然后返回执行操作的对象：
```cpp
class Screen {
public:
  // 根据对象是否是const重载了display函数
  Screen &display(std::ostream &os) {
    do_display(os);
    return *this;
  }
  const Screen &display(std::ostream &os) const {
    do_display(os);
    return *this;
  }
private:
  void do_display(std::ostream &os) const {
    os << contents;
  }
};
```

当对象调用`display`时，该对象是否是`const`决定了该调用哪个版本。

## 1.8 类相关的非成员函数
类通常需要定义一些辅助函数，它们概念上来说属于类的接口部分，但它们并不属于类本身，这些函数的声明应与类在同一个头文件中，这样，类的用户在使用类的接口时只需要引入一个头文件。

例如`Sales_data`类的`read`函数：
```cpp
istream &read(istream &is, Sales_data &item) {
  double price;
  is >> item.bookNo >> item.units_sold >> price;
  item.revenue = price * item.units_sold;
  return is;
}
```

这个函数从给定流中将数据读到给定对象里，函数接受一个`IO`类型的引用作为其参数，这是因为`IO`类属于不能被拷贝的类型，只能通过引用来传递，且读取操作会改变流的内容，使用的是普通引用。

## 1.9 构造函数
构造函数不能被声明成`const`的，当创建一个`const`对象时，直到构造函数完成初始化过程，对象才能真正取得其常量属性，因此，构造函数可以在`const`对象的构造过程中向其写值。

### 1.9.1 合成的默认构造函数
若类没有显示定义构造函数，编译器会隐式定义一个默认构造函数，其按如下规则初始化类的数据成员：
1. 若存在类内初始值，使用类内初始值初始化数据成员，C++11标准规定可以为数据成员提供一个**类内初始值**，创建对象时，类内初始值用于初始化数据成员，类内初始值可以放在花括号里或放在等号右边，但是不能使用圆括号
2. 否则，默认初始化该成员

默认构造函数无需任何实参。

> 只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数

某些情况下合成的默认构造函数可能执行错误的操作，定义在块作用域中的内置类型或复合类型（数组或指针）的对象执行默认初始化的值将是未定义的，因此，含有内置类型或复合类型成员的类应在类内部初始化这些成员或定义一个自己的默认构造函数，否则用户在创建类对象时就可能得到未定义的值。

> 若类包含内置类型或复合类型的成员，则只有当这些成员全都被赋予了类内初始值时，这个类才适合于使用合成的默认构造函数

注意某些情况下编译器不能为类合成默认构造函数，例如类中包含一个其它类类型的成员且这个成员的类型没有默认构造函数。

### 1.9.2 =default的含义
一般来说定义这个构造函数的目的是因为既需要其他形式的构造函数，也需要默认的构造函数，且希望这个函数的作用完全等同于合成默认构造函数，通过在参数列表后面写上`= default`来要求编译器生成构造函数。

注意，若编译器不支持类内初始值，那么默认构造函数就应该使用构造函数初始化列表来初始化成员。

### 1.9.3 构造函数初始值列表
对象的数据成员若没有在构造函数的初始值列表中显示初始化，则该成员将在构造函数体之前执行默认初始化。

有时可以忽略数据成员初始化和赋值之间的差异，但若成员是const或引用时，必须将其初始化，类似的，当成员属于某种类类型且该类没有定义默认构造函数时，也必须进行初始化。

很多类中，初始化和赋值的区别事关底层效率问题：前者直接初始化成员，后者先初始化再赋值。

### 1.9.4 成员初始化顺序
成员的初始化顺序与它们在类定义中的出现顺序一致，构造函数初始化列表中初始值的前后位置关系不会影响实际的初始化顺序。

一般来说，对初始化顺序没有特别的要求，但如果一个成员是用另一个成员来初始化的，那么这两个成员的初始化顺序就很关键了：
```cpp
class X {
public:
  X(int val): j(val), i(j) {} // 未定义：i在j之前被初始化
private:
  int i;
  int j;
};
```

> 最好令构造函数初始值的顺序与成员声明顺序保持一致，若可能的话，尽量避免使用某些成员初始化其它成员

### 1.9.5 默认实参和构造函数
如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。

### 1.9.6 委托构造函数
C++11标准扩展了构造函数初始化的功能，使得可以定义委托构造函数，它使用所属类的其它构造函数执行其自己的初始化过程，或者说它把自己的一些或全部工作委托给了其它构造函数。

委托构造函数的成员初始值列表只有一个唯一的入口，即类名本身，以`Sales_data`类为例：
```cpp
class Sales_data {
public:
  // 非委托构造函数使用对应的实参初始化成员
  Sales_data(std::string s, unsigned cnt, double price): bookNo(s), units_sold(cnt), revenue(cnt*price) {}
  // 其它构造函数委托给另一个构造函数
  Sales_data(): Sales_data("", 0, 0) {}
  Sales_data(std::string s): Sales_data(s, 0, 0) {}
  Sales_data(std::istream &is): Sales_data() {read(is, *this);}
};
```

### 1.9.7 默认构造函数的作用
当对象被默认初始化或值初始化时自动执行默认构造函数，默认初始化发生在以下几种情况：
1. 块作用域中不使用任何初始值定义一个非静态变量或数组
2. 一个类本身含有类类型的成员且使用合成的默认构造函数时（合成的默认构造函数会调用类类型成员的默认构造函数来进行初始化，并不会初始化内置或复合类型的成员）
3. 类类型的成员没有在构造函数初始值列表中显示初始化时

值初始化发生在以下几种情况：
1. 数组初始化过程中提供的初始值数量少于数组的大小时
2. 不使用初始值定义一个局部静态变量时
3. 用形如`T( )`的表达式显示地请求值初始化时，其中T是类型名，例如`vector<int>(5)`只接受一个实参用于说明`vector`大小

类必须包含一个默认构造函数以便在上述情况下使用，比如某些数据成员缺少默认构造函数的情况：
```cpp
class NoDefault {
public:
  NoDefault(const std::string &);
  // 还有其它成员，但没有其它构造函数了
};
struct A {
  NoDefault my_mem;
};
A a; // 错误：不能为A合成构造函数
struct B {
  B() {} // 错误：b_mem没有初始值
  NoDefault b_mem;
};
```

### 1.9.8 隐式类类型转换
若构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，这种构造函数也被称为转换构造函数。

> 能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则，即需要类类型的地方可以使用构造函数参数类型作为替代，会生成一个临时类对象

```cpp
string null_book = "9-999-9999";
// 构造一个临时的Sales_data对象
// combine接受Sales_data类型的参数
// combine参数类型为常量引用，所以可以给该参数传递一个临时量
item.combine(null_book);
```

> 只允许一步类类型转换

编译器只会自动执行一步类型转换：
```cpp
// 错误：两步转换
// 1. 把"9-999-9999"转换为string
// 2. 把这个临时的string转换为Sales_data
item.combine("9-999-9999");
```

> 抑制构造函数定义的隐式转换

通过将构造函数声明为`explicit`加以阻止，只需在类内声明构造函数时使用`explicit`关键字，类外部定义时不应重复：
```cpp
class Sales_data {
public:
  explicit Sales_data(const std::string &s): bookNo(s) {}
  explicit Sales_data(std::istream &);
};
```

> explicit构造函数只能用于直接初始化

发生隐式转换的一种情况是执行拷贝形式的初始化（使用`=`），因此，不能将`explicit`构造函数用于拷贝形式的初始化：
```cpp
Sales_data item1(null_book); // 正确：直接初始化
Sales_data item2 = null_book; // 错误
```

> 为转换显示地使用构造函数

尽管编译器不会将`explicit`的构造函数用于隐式转换过程，但可以使用这样的构造函数显示地强制进行转换：
```cpp
// 正确：实参是一个显示构造的Sales_data对象
item.combine(Sales_data(null_book));
// 正确：static_cast可以使用explicit构造函数
item.combine(static_cast<Sales_data>(cin));
```

## 1.10 拷贝、赋值和析构
除了控制类的初始化之外，还需要控制拷贝、赋值和销毁对象时的行为；对象在初始化变量及以值的方式传递或返回一个对象等情况下会被拷贝，当使用赋值运算符时会发生对象的赋值操作，当对象生命周期结束时会执行销毁操作；和构造函数一样，若不主动定义这些操作，编译器将会生成默认的版本，编译器生成的版本将对对象的每个成员执行拷贝、赋值和销毁操作。

注意当类需要分配类对象之外的资源时，合成的版本无法正常工作，即管理动态内存的类通常不能依赖于合成的版本，不过很多需要动态内存的类可以（应该）通过`vector`或`string`对象管理必要的存储空间，使用他们能避免分配和释放内存带来的复杂性，即若类包含`vector`或`string`成员，则其拷贝、赋值和销毁的合成版本能够正常工作。

## 1.11 类型成员
除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名，称为**类型成员**，与其它成员一样存在访问限制，与普通成员不同的是类型成员必须先定义后使用，因此，类型成员通常出现在类开始的地方。

## 1.12 内联成员函数
定义在类内部的成员是自动`inline`的，还可以在类内部把`inline`作为声明的一部分显示地声明成员函数或在类的外部用`inline`修饰函数的定义，不过建议只在类外部定义的地方说明`inline`，这样可以使类更容易理解。

`inline`成员函数应该与相应的类定义在同一个头文件中。

## 1.13 mutable可变数据成员
有时希望能够修改类的某个数据成员，即使在一个const成员函数内，通过在变量声明中加入`mutable`关键字可以使`const`成员函数修改这一变量。

## 1.14 类类型
每个类定义了唯一的类型，对两个类来说，即使他们的成员完全一样，这两个类也是不同的类型，类名即为类型的名字。

## 1.15 类的声明
仅仅声明类而暂时不定义它的行为称为**前向声明**，它向程序中引入类名字且指明该名字是一种类类型，在定义之前，它是一个不完全类型，只能在有限的情景下使用：定义指向这种类型的指针或引用，也可以声明（但不能定义）以不完全类型作为参数或返回类型的函数。

## 1.16 聚合类
聚合类使得用户可以直接访问其成员且具有特殊的初始化语法，当一个类满足如下几个条件时为聚合类：
1. 所有成员都是public
2. 未定义任何构造函数
3. 没有类内初始值
4. 没有基类
5. 没有virtual函数

```cpp
// 聚合类
struct Data {
  int ival;
  string s;
};
```

> 用花括号括起来的成员初始值列表进行聚合类的初始化，初始值顺序需要与声明顺序一致

```cpp
// val1.ival = 0; val1.s = string("Anna");
Data val1 = {0, "Anna"};
```

与初始化数组元素类似，若初始值列表中元素个数少于类的成员数量，则靠后的成员被值初始化；初始值列表的元素个数不能超过类的成员数量。

## 1.17 字面值常量类
数据成员都是字面值类型的聚合类是字面值常量类，如果一个类不是聚合类

字面值类型的类可能含有`constexpr`函数成员，这样的成员必须符合`constexpr`函数的所有要求，它们是隐式`const`的。

### 1.17.1 字面值类型
> 字面值常量
一个形如`42`的值被称为字面值常量，它的值一望而知，每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型：
- 整型和浮点型字面值
- 字符和字符串字面值
- 布尔字面值和指针字面值（nullptr或0）

> 常量表达式
常量表达式指值不会改变且在编译过程就能得到计算结果的表达式，显然字面值属于常量表达式，用常量表达式初始化的`const`对象也是常量表达式，一个对象是否是常量表达式由它的数据类型和初始值共同决定：
```cpp
const int max_files = 20; // 常量表达式
const int limit = max_files + 1; // 常量表达式
int staff_sizee = 27; // 非常量表达式，初始值为字面值常量，但是数据类型不是const
const int sz = get_size(); // 非常量表达式，数据类型是const，但初始值编译时不能得到，直到运行时才可得到
```

> constexpr变量
不能确定一个初始值到底是不是常量表达式时，可以将变量声明为`constexpr`类型以便由编译器来验证变量的值是否为一个常量表达式，声明为`constexpr`的变量一定是一个常量且必须用常量表达式初始化：
```cpp
constexpr int mf = 20; //常量表达式
constexpr int limit = mf + 1; // 常量表达式
constexpr int sz = size(); // 只有size()是一个constexpr函数时才是一条正确的声明语句
```

一般来说，如果确定变量是常量表达式，那就把它声明为constexpr类型

> 字面值类型
声明`constexpr`的类型一般比较简单，值也显而易见、容易得到，把它们统称为**字面值类型**，算数类型、引用和指针类型都属于字面值类型，尽管指针和引用都能定义为`constexpr`，但其初始值必须是nullptr或0，或是存储于某个固定地址中的对象，定义于所有函数体之外的变量其地址固定不变，可用来初始化`constexpr`指针，注意`constexpr`限定符只对指针有效，与其所指对象无关：
```cpp
const int *p = nullptr; // p是一个指向整型常量的指针
constexpr int *q = nullptr; // q是一个指向整数的常量指针
```

### 1.17.2 constexpr函数
`constexpr`函数是指能用于常量表达式的函数，返回类型和所有形参的类型都要是字面值类型，且函数必须有且只有一条返回语句：
```cpp
constexpr int new_sz() return { 42; }
constexpr int foo = new_sz();
```

编译器会将`constexpr`函数的调用替换为其结果值，因此其被隐式地指定为内联函数。

`constexpr`函数的函数体也可包含一些不执行任何操作的语句，例如空语句、类型别名及using声明。

> constexpr函数不一定返回常量表达式
```cpp
constexpr size_t scale(size_t cnt) { return new_sz * cnt; }
```
当`scale`的实参是常量表达式时，它的返回值也是常量表达式，反之则不然：
```cpp
int arr[scale(2)]; // 正确：scale(2)是常量表达式
int i = 2;
int arr2[scale(i)]; //错误：scale(i)不是常量表达式
```

> 把内联函数和constexpr函数放在头文件中

### 1.17.3 


# 2. 访问控制与封装
访问控制是对类的实现进行封装，C++中使用**访问说明符**加强类的封装性：
- 定义在`public`说明符之后的成员在整个程序内可被访问，`public`成员定义类的接口
- 定义在`private`说明符之后的成员可被类的成员函数访问，但不能被使用该类的代码访问，`private`说明符部分封装了类的实现细节

## 2.1 class和struct关键字
都可以定义类，唯一的区别是`struct`和`class`的默认访问权限不一样，类可以在它的第一个访问说明符之前定义成员，若定义类时使用`struct`关键字，则定义在第一个访问说明符之前的成员是`public`的，相反，若使用`class`关键字，这些成员是`private`的。

## 2.2 友元
若某些类相关的非成员函数需要使用类的私有成员，尽管它们是类接口的一部分，但它们不是类的成员，C++中类允许其他类或函数访问它的非公有成员，方法是令其它类或函数成为它的**友元**，即在声明前加上`friend`关键字。

友元的声明只能出现在类定义的内部，不受它所在区域访问控制级别的约束，一般来说，最好在类定义开始或结束前的位置集中声明友元。

注意友元的声明仅仅指定了访问的权限而非一个通常意义上的函数声明，需要在友元声明之外再专门对友元函数进行一次声明，通常把友元函数的声明与类放置在同一个头文件中。

> 除了普通函数，类还可以把其它类或其它类的成员函数定义为友元。

### 2.2.1 类之间的友元关系
假设有一个窗口管理类`Window_mgr`类负责管理`Screen`类，其包含一个`Screen`类型的`vector`：
```cpp
class Window_mgr {
private:
  // 默认情况下，包含一个标准尺寸的空白Screen
  std::vector<Screen> screens{Screen(24, 80, ' ')};
};
```

若`Window_mgr`类有一个`clear`接口负责把一个指定`Screen`的内容清空，那么`clear`需要访问`Screen`的私有成员，即`Screen`需要把`Window_mgr`指定为它的友元：
```cpp
class Screen {
  // Window_mgr的成员可以访问Screen的私有部分
  friend class Window_mgr;
};
```

那么`clear`可以写为如下形式：
```cpp
class Window_mgr {
public:
  // 窗口每个屏幕的编号
  using ScreenIndex = std::vector<Screen>::size_type;
  void clear(ScreenIndex);
private:
  std::vector<Screen> screens{Screen(24, 80, ' ')};
}
void Window_mgr::clear(ScrrenIndex i) {
  Screen &s = screens[i];
  s.contents = string(s.height * s.width, ' ');
};
```

> 每个类负责控制自己的友元类或友元函数，即友元关系不存在传递性，即`Window_mgr`的友元不能理所当然地具有访问`Screen`的特权

### 2.2.2 令成员函数作为友元
上例中还可以只为`clear`提供访问权限，当把一个成员函数声明为友元时，必须明确指出该成员函数属于哪个类：
```cpp
class Screen {
  //Window_mgr::clear必须在Screen类之前被声明
  friend void Window_mgr::clear(ScreenIndex);
}
```

要令某个成员函数作为友元，必须仔细组织程序结构以满足声明和定义的彼此依赖关系：
1. 首先定义`Window_mgr`类，声明`clear`函数，但**不能定义它**
2. 定义`Screen`类，包括对`clear`的友元声明
3. 定义`clear`，此时它才可以使用`Screen`的成员

### 2.2.3 函数重载和友元
尽管重载函数的名字相同，但它们仍是不同的函数，因此，一个类想把一组重载函数声明为它的友元，需要对这组函数中的每一个分别声明。

### 2.2.4 友元声明和作用域
类和非成员函数的声明不是必须在它们的友元声明之前，当一个名字第一次出现在一个友元声明时，隐式地假设该名字在当前作用域中是可见的（然而，友元本身不一定真的声明在当前作用域中），就算在类内部定义友元函数，也必须在类外部提供相应的声明从而使得函数可见，否则无法使用该函数。
```cpp
struct X {
  friend void f() {/* 友元函数可以定义在类内部 */}
  X() { f(); } // 错误：f还没有被声明，不可见
  void g();
  void h();
};
void X::g() { f(); } // 错误：f还没有被声明
void f(); //声明在X中定义的f函数
void X::h() { f(); } // 正确：现在f的声明在作用域中了
```

## 2.3 类的作用域
一个类就是一个作用域，在类的外部定义成员函数时必须同时提供类名和函数名，一旦遇到类名，定义的剩余部分（参数列表和函数体）就在类的作用域之内了，即可以直接使用类的其它成员而无需再加类名。
由于函数的返回类型通常出现在函数名之前，因此当成员函数定义在类外部时，返回类型中使用的名字都位于类作用域之外，此时需要指明它是哪个类的成员。

### 2.3.1 名字查找与类的作用域
> 编译器处理完类中的全部声明后才会处理成员函数的定义，由于成员函数体直到整个类可见后才被处理，所以它能使用类中定义的任何名字，这样可以简化类代码的组织方式，否则函数的定义和成员的声明被同时处理的话，将不得不在成员函数中只使用那些已出现的名字

### 2.3.2 类成员声明的名字查找
如上规则只适用于成员函数中使用的名字，对于声明中的名字（包括返回类型和参数列表中使用的名字），都必须在使用前确保可见。

### 2.3.3 类型名要特殊处理
一般来说，内层作用域可以重新定义外层作用域中的名字，及时该名字已经在内层作用域中使用过，然而类中若成员使用了外层作用域的某个名字且该名字代表一种类型，则类不能在之后重新定义该名字：
```cpp
typedef double Money;
class Account {
public:
  Money balance() {return bal;} // 使用外层作用域的Money
private:
  typedef int Money; // 错误：不能重新定义Money
  Money bal;
};
```

```
error: changes meaning of ‘Money’ from ‘typedef double Money’ to ‘typedef int Account::Money’
```

注意，即使重定义与外层作用域一致：`typedef double Money`，仍然会报错。

> 类型名的定义通常出现在类的开始处，这样就能保证所有使用该类型的成员都出现在类型名的定义后

```cpp
typedef double Money;
class Account {
  typedef int Money;

 public:
  Money balance() { return bal; } // 使用类型名

 private:
  Money bal;  // 使用类型名
};
```

### 2.3.4 成员定义中的普通作用域的名字查找
成员函数中使用的名字按照如下方式解析：
1. 在成员函数内查找该名字的声明
2. 若在成员函数内未找到，在类内继续查找，此时类的所有成员都可以被考虑
3. 若类内也没有找到该名字的声明，在成员函数定义之前的作用域内继续查找

> 一般不建议使用其它成员的名字作为某个成员函数的参数，因为这样会隐藏掉同名的成员，若需要使用成员，必须加上类的名字作用域运算符或显示地使用this指针强制访问成员

### 2.3.5 名字出现处进行解析
当成员定义在类的外部时，2.3.4中名字查找的第三步不仅要考虑类定义之前的全局作用域中的声明，还需要考虑在成员函数定义之前的全局作用域中的声明：
```cpp
int height;
class Screen {
public:
  typedef std::string::size_type pos;
  void setHeight(pos);
  pos height; // 隐藏了外层作用域的height
};
Screen::pos verify(Screen::pos);
void Screen::setHeight(pos var) {
  height = verify(var);
}
```

全局函数`verify`的声明在`Screen`类的定义之前是不可见的，其出现在成员函数出现之前的全局作用域中，可被正常使用。

