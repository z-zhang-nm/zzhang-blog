---
title: "类"
date: 2021-05-18T11:01:11+08:00
categories:
- C++
- C++Primer
tags:
- 类
keywords:
- tech
#thumbnailImage: //example.com/image.jpg
---
类的设计
<!--more-->
# 1. 抽象数据类型
类的基本思想是**数据抽象**和**封装**，数据抽象是一种依赖于**接口**和**实现**分离的编程技术，接口包括用户所能执行的操作，实现包括类的数据成员、负责接口实现的函数体以及定义类所需要的各种私有函数；封装后的类隐藏了实现细节，类的用户只能使用接口而无法访问实现部分。

## 1.1 this指针
成员函数通过一个名为`this`的隐式参数来访问调用它的对象，当类的实例化对象调用一个成员函数时，用该对象的地址初始化`this`，可以等价地认为编译器将成员函数的调用重写为如下形式：
```cpp
total.isbn();
// 等价形式，用于说明调用成员函数的实际执行过程
Sales_data::isbn(&total);
```

在成员函数内部可以直接调用类的成员，也可以显示使用this（没必要），例如：
```cpp
std::string isbn() const {
  // return bookNo;
  return this->bookNo;
}
```

## 1.2 const成员函数
如`isbn()`函数参数列表之后的`const`关键字，其作用是修改`this`指针的类型，默认情况下，`this`指针的类型是指向类类型的**非常量版本的常量指针**，例如在`Sales_data`成员函数中，`this`的类型是`Sales_data *const`，遵循初始化规则，`this`指针不能绑定到一个常量对象上，即不能在一个常量对象上调用普通的成员函数，因此有时候为了提高函数的灵活性会将`this`声明为指向常量的指针，而`this`是隐式的，并不会出现在参数列表中，所以将`const`放在参数列表后，使用`const`的成员函数被称作**常量成员函数**。
```cpp
// isbn函数的伪代码，用来说明this指针的用法
std::string Sales_data::isbn(const Sales_data *const this) {
  return this->bookNo;
}
```

> 常量对象及常量对象的引用或指针都只能调用常量成员函数

## 1.3 编译器对类成员的处理
编译器分两步处理类：
1. 编译成员的声明
2. 编译成员函数体

因此，成员函数体可以随意使用类中的其它成员而无需在意这些成员出现的次序。

## 1.4 类外部定义成员函数
当在类外部定义成员函数时，成员函数的定义必须与它的声明匹配，也就是说**返回类型、参数列表和函数名**都要与类内部的声明一致，同时函数名前需要**指定类名作用域**，常量成员函数在类外部定义时也需要在参数列表后指定`const`属性。

## 1.5 返回this对象的成员函数
模拟复合赋值运算符`+=`，`Sales_data`类的成员函数`combine`需要返回引用类型，如下：
```cpp
Sales_data& Sales_data::combine(const Sales_data &rhs) {
  units_sold += rhs.units_sold;
  revenue += rhs.revenue;
  return *this; // 返回total的引用
}

total.combine(trans); // total地址被绑定到隐式this，rhs绑定到trans
```

## 1.6 类相关的非成员函数
类通常需要定义一些辅助函数，它们概念上来说属于类的接口部分，但它们并不属于类本身，这些函数的声明应与类在同一个头文件中，这样，类的用户在使用类的接口时只需要引入一个头文件。

例如`Sales_data`类的`read`函数：
```cpp
istream &read(istream &is, Sales_data &item) {
  double price;
  is >> item.bookNo >> item.units_sold >> price;
  item.revenue = price * item.units_sold;
  return is;
}
```

这个函数从给定流中将数据读到给定对象里，函数接受一个`IO`类型的引用作为其参数，这是因为`IO`类属于不能被拷贝的类型，只能通过引用来传递，且读取操作会改变流的内容，使用的是普通引用。

## 1.7 构造函数基础
构造函数不能被声明成`const`的，当创建一个`const`对象时，直到构造函数完成初始化过程，对象才能真正取得其常量属性，因此，构造函数可以在`const`对象的构造过程中向其写值。

### 1.7.1 合成的默认构造函数
若类没有显示定义构造函数，编译器会隐式定义一个默认构造函数，其按如下规则初始化类的数据成员，默认构造函数无需任何实参：
1. 若存在类内初始值，C++11标准规定可以为数据成员提供一个**类内初始值**，创建对象时，类内初始值用于初始化数据成员，类内初始值可以放在花括号里或放在等号右边，但是不能使用圆括号
2. 否则，默认初始化该成员

> 只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数

某些情况下合成的默认构造函数可能执行错误的操作，定义在块作用域中的内置类型或复合类型（数组或指针）的对象执行默认初始化的值将是未定义的，因此，含有内置类型或复合类型成员的类应在类内部初始化这些成员或定义一个自己的默认构造函数，否则用户在创建类对象时就可能得到未定义的值。

> 若类包含内置类型或复合类型的成员，则只有当这些成员全都被赋予了类内初始值时，这个类才适合于使用合成的默认构造函数

注意某些情况下编译器不能为类合成默认构造函数，例如类中包含一个其它类类型的成员且这个成员的类型没有默认构造函数。

### 1.7.2 =default的含义
一般来说定义这个构造函数的目的是因为既需要其他形式的构造函数，也需要默认的构造函数，且希望这个函数的作用完全等同于合成默认构造函数，通过在参数列表后面写上`= default`来要求编译器生成构造函数。

注意，若编译器不支持类内初始值，那么默认构造函数就应该使用构造函数初始化列表来初始化成员。

## 1.8 拷贝、赋值和析构基础
除了控制类的初始化之外，还需要控制拷贝、赋值和销毁对象时的行为；对象在初始化变量及以值的方式传递或返回一个对象等情况下会被拷贝，当使用赋值运算符时会发生对象的赋值操作，当对象生命周期结束时会执行销毁操作；和构造函数一样，若不主动定义这些操作，编译器将会生成默认的版本，编译器生成的版本将对对象的每个成员执行拷贝、赋值和销毁操作。

注意当类需要分配类对象之外的资源时，合成的版本无法正常工作，即管理动态内存的类通常不能依赖于合成的版本，不过很多需要动态内存的类可以（应该）通过`vector`或`string`对象管理必要的存储空间，使用他们能避免分配和释放内存带来的复杂性，即若类包含`vector`或`string`成员，则其拷贝、赋值和销毁的合成版本能够正常工作。

# 2. 访问控制与封装
