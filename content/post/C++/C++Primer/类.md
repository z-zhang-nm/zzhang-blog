---
title: "类"
date: 2021-05-18T11:01:11+08:00
categories:
- C++
- C++Primer
tags:
- 类
keywords:
- tech
#thumbnailImage: //example.com/image.jpg
---
类的设计
<!--more-->
# 1. 抽象数据类型
类的基本思想是**数据抽象**和**封装**，数据抽象是一种依赖于**接口**和**实现**分离的编程技术，接口包括用户所能执行的操作，实现包括类的数据成员、负责接口实现的函数体以及定义类所需要的各种私有函数；封装后的类隐藏了实现细节，类的用户只能使用接口而无法访问实现部分。

# 2. this指针
成员函数通过一个名为`this`的隐式参数来访问调用它的对象，当类的实例化对象调用一个成员函数时，用该对象的地址初始化`this`，可以等价地认为编译器将成员函数的调用重写为如下形式：
```cpp
total.isbn();
// 等价形式，用于说明调用成员函数的实际执行过程
Sales_data::isbn(&total);
```

在成员函数内部可以直接调用类的成员，也可以显示使用this（没必要），例如：
```cpp
std::string isbn() const {
  // return bookNo;
  return this->bookNo;
}
```

# 3. const成员函数
如`isbn()`函数参数列表之后的`const`关键字，其作用是修改`this`指针的类型，默认情况下，`this`指针的类型是指向类类型的**非常量版本的常量指针**，例如在`Sales_data`成员函数中，`this`的类型是`Sales_data *const`，遵循初始化规则，`this`指针不能绑定到一个常量对象上，即不能在一个常量对象上调用普通的成员函数，因此有时候为了提高函数的灵活性会将`this`声明为指向常量的指针，而`this`是隐式的，并不会出现在参数列表中，所以将`const`放在参数列表后，使用`const`的成员函数被称作**常量成员函数**。
```cpp
// isbn函数的伪代码，用来说明this指针的用法
std::string Sales_data::isbn(const Sales_data *const this) {
  return this->bookNo;
}
```

> 常量对象及常量对象的引用或指针都只能调用常量成员函数

# 4. 编译器对类成员的处理
编译器分两步处理类：
1. 编译成员的声明
2. 编译成员函数体

因此，成员函数体可以随意使用类中的其它成员而无需在意这些成员出现的次序。

# 5. 类外部定义成员函数
当在类外部定义成员函数时，成员函数的定义必须与它的声明匹配，也就是说**返回类型、参数列表和函数名**都要与类内部的声明一致，同时函数名前需要**指定类名作用域**，常量成员函数在类外部定义时也需要在参数列表后指定`const`属性。

# 6. 返回this对象的成员函数
模拟复合赋值运算符`+=`，`Sales_data`类的成员函数`combine`需要返回引用类型，如下：
```cpp
Sales_data& Sales_data::combine(const Sales_data &rhs) {
  units_sold += rhs.units_sold;
  revenue += rhs.revenue;
  return *this; // 返回total的引用
}

total.combine(trans); // total地址被绑定到隐式this，rhs绑定到trans
```

# 7. 类相关的非成员函数
类通常需要定义一些辅助函数，它们概念上来说属于类的接口部分，但它们并不属于类本身，这些函数的声明应与类在同一个头文件中，这样，类的用户在使用类的接口时只需要引入一个头文件。

例如`Sales_data`类的`read`函数：
```cpp
istream &read(istream &is, Sales_data &item) {
  double price;
  is >> item.bookNo >> item.units_sold >> price;
  item.revenue = price * item.units_sold;
  return is;
}
```

这个函数从给定流中将数据读到给定对象里，函数接受一个`IO`类型的引用作为其参数，这是因为`IO`类属于不能被拷贝的类型，只能通过引用来传递，且读取操作会改变流的内容，使用的是普通引用。

# 8. 构造函数

