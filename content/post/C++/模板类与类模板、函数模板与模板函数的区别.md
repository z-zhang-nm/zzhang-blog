---
title: "模板类与类模板、函数模板与模板函数的区别"
date: 2020-08-05T15:33:11+08:00
categories:
- C++
tags:
- 模板类与类模板
- 函数模板与模板函数
keywords:
- tech
#thumbnailImage: //example.com/image.jpg
---
[参考链接](https://blog.csdn.net/sunxx1986/article/details/6619144)
<!--more-->
# 模板类与类模板、函数模板与模板函数的区别

## 1 概述
　　C++中有几个容易混淆的术语，分别为：
1. 函数指针 <--> 指针函数
2. 数组指针 <--> 指针数组
3. 类模板 <--> 模板类
4. 函数模板 <--> 模板函数

## 2 函数指针与指针函数
　　从名字就可以看出来，函数指针的重点是**指针**，表示其为一个指针，指向的是一个函数，而指针函数的重点是**函数**，表示其为一个函数，它的返回类型是指针类型。

```cpp
type (*pf)(params); //函数指针
type *fun(params); //指针函数
```

## 3 数组指针与指针数组
　　数组指针重点是**指针**，表示一个指针，指向的是一个数组，而指针数组重点是**数组**，表示一个数组，它的元素为指针。

```cpp
int (*pa)[8]; //数组指针
int *ap[8]; //指针数组
```

## 4 类模板与模板类
　　类模板的重点是**模板**，用于产生类的模子。
```cpp
template <typename T>
class Vector{
    ...
};
```

　　使用这个Vector模板就可以产生很多的类，产生的类叫做模板类，比如`Vector<int>, Vector<Vector<int>>, Vector<double>`等。

> **类模板的声明与实现最好放在同一个头文件中**

### 4.1 尝试以普通类方式实现类模板的分离式编译
```cpp
//test.h
#pragma once

template <typename T>
class Test {
 public:
  Test(const T& t);
  const T& read() const;
  void write(const T& x);

 private:
  T val;
};
```
```cpp
//test.cpp
#include "test.h"

template <typename T>
Test<T>::Test(const T& t) {
  val = t;
}

template <typename T>
const T& Test<T>::read() const {
  return val;
}

template <typename T>
void Test<T>::write(const T& x) {
  val = x;
}
```
```cpp
//main.cpp
#include <iostream>

#include "test.h"

using namespace std;

int main() {
  Test<int> t1(1);
  Test<double> t2(1.5);

  t1.write(2);
  t2.write(2.5);

  cout << t1.read() << endl;
  cout << t2.read() << endl;
  return 0;
}
```

　　上面的代码在进行编译时会报`undefined reference`的错误，首先说下这个错误：
> 在Linux下用C/C++工作的时候，经常会遇到"undefined reference to XXX"的问题，直白地说就是在**链接**(从.cpp源代码到可执行的ELF文件，要经过预处理->编译->链接三个阶段，此时预处理和编译已经通过了)的时候，链接器找不到XXX这个函数的定义了。

### 4.2 番外，聊聊undefined reference这个错误
　　假设有如下几段代码:
```cpp
//foo.h
#pragma once

void foo();
```
```cpp
//foo.cpp
#include "foo.h"

#include <iostream>

void foo() { std::cout << "This is function foo." << std::endl; }
```
```cpp
//main.cpp
#include <iostream>
#include "foo.h"

using namespace std;

int main() {
  foo();

  return 0;
}
```
#### 4.2.1 链接时缺少定义了XXX的源文件或者目标文件或者库文件
1. 缺源文件：若用`g++ mian.cpp`命令进行编译，会出现"undefined reference to foo()"的错误，编译时加上`foo.cpp`即可，`g++ main.cpp foo.cpp`
2. 缺目标文件：先将`foo.cpp`编译为目标文件文件`foo.o`后，也可以用`foo.o`来编译，`g++ -c foo.cpp`，直接使用`g++ main.cpp`也会报"undefined reference to foo()"的错误，用`g++ main.cpp foo.o`编译即可
3. 缺库文件：把foo.cpp编译成动态库（静态库一样的）文件`foo.so`也一样，首先``