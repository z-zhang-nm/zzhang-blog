---
title: "模板类与类模板、函数模板与模板函数的区别"
date: 2020-08-05T15:33:11+08:00
categories:
- C++
tags:
- 模板类与类模板
- 函数模板与模板函数
keywords:
- tech
#thumbnailImage: //example.com/image.jpg
---
[参考链接](https://blog.csdn.net/sunxx1986/article/details/6619144)
<!--more-->
# 模板类与类模板、函数模板与模板函数的区别

## 1 概述
　　C++中有几个容易混淆的术语，分别为：
1. 函数指针 <--> 指针函数
2. 数组指针 <--> 指针数组
3. 类模板 <--> 模板类
4. 函数模板 <--> 模板函数

## 2 函数指针与指针函数
　　从名字就可以看出来，函数指针的重点是**指针**，表示其为一个指针，指向的是一个函数，而指针函数的重点是**函数**，表示其为一个函数，它的返回类型是指针类型。

```cpp
type (*pf)(params); //函数指针
type *fun(params); //指针函数
```

## 3 数组指针与指针数组
　　数组指针重点是**指针**，表示一个指针，指向的是一个数组，而指针数组重点是**数组**，表示一个数组，它的元素为指针。

```cpp
int (*pa)[8]; //数组指针
int *ap[8]; //指针数组
```

## 4 类模板与模板类
　　类模板的重点是**模板**，用于产生类的模子。
```cpp
template <typename T>
class Vector{
    ...
};
```

　　使用这个Vector模板就可以产生很多的类，产生的类叫做模板类，比如`Vector<int>, Vector<Vector<int>>, Vector<double>`等。

> **类模板的声明与实现最好放在同一个头文件中**

### 4.1 尝试以普通类方式实现类模板的分离式编译
```cpp
//test.h
#pragma once

template <typename T>
class Test {
 public:
  Test(const T& t);
  const T& read() const;
  void write(const T& x);

 private:
  T val;
};
```
```cpp
//test.cpp
#include "test.h"

template <typename T>
Test<T>::Test(const T& t) {
  val = t;
}

template <typename T>
const T& Test<T>::read() const {
  return val;
}

template <typename T>
void Test<T>::write(const T& x) {
  val = x;
}
```
```cpp
//main.cpp
#include <iostream>

#include "test.h"

using namespace std;

int main() {
  Test<int> t1(1);
  Test<double> t2(1.5);

  t1.write(2);
  t2.write(2.5);

  cout << t1.read() << endl;
  cout << t2.read() << endl;
  return 0;
}
```

　　上面的代码在进行编译时会报`undefined reference`的错误，首先说下这个错误：
> 在Linux下用C/C++工作的时候，经常会遇到"undefined reference to XXX"的问题，直白地说就是在**链接**(从.cpp源代码到可执行的ELF文件，要经过预处理->编译->链接三个阶段，此时预处理和编译已经通过了)的时候，链接器找不到XXX这个函数的定义了。

### 4.2 番外，聊聊undefined reference这个错误
　　假设有如下几段代码:
```cpp
//foo.h
#pragma once

void foo();
```
```cpp
//foo.cpp
#include "foo.h"

#include <iostream>

void foo() { std::cout << "This is function foo." << std::endl; }
```
```cpp
//main.cpp
#include <iostream>
#include "foo.h"

using namespace std;

int main() {
  foo();

  return 0;
}
```
#### 4.2.1 链接时缺少定义了XXX的源文件或者目标文件或者库文件
1. 缺源文件：若用`g++ mian.cpp`命令生成可执行文件，会出现"undefined reference to foo()"的错误，命令行加上`foo.cpp`即可，`g++ main.cpp foo.cpp`
2. 缺目标文件：先将`foo.cpp`编译为目标文件文件`foo.o`后，也可以用`foo.o`来编译，`g++ -c foo.cpp`，直接使用`g++ main.cpp`也会报"undefined reference to foo()"的错误，用`g++ main.cpp foo.o`即可
3. 缺库文件：把foo.cpp编译成动态库（静态库一样的）文件`foo.so`也一样，首先`g++ --shared -fPIC -o foo.so foo.cpp`生成`foo.so`，然后`g++ main.cpp foo.so`

> 上面第三种方法生成动态库文件后需要先链接到`/usr/lib`或`/lib`目录下，否则会报`cannot open shared object file: No such file or directory`的错误

#### 4.2.2 链接顺序不对
　　若上一节中第三条将`foo.so`和`main.cpp`文件前后顺序调换`g++ foo.so main.cpp`，也会出现"undefined reference to foo()"的错误，因为给编译器输入源文件、目标文件或动态静态库文件时，若B文件依赖A文件，那么B文件应该放在A文件的**左边**。

#### 4.2.3 函数符号修饰不一样
　　符号修饰即函数从源代码编译到目标文件时，函数在目标文件中的名字是会改变的，在链接阶段，链接器按照函数改变后的名字来索引函数，函数改变后的名字不一样的函数在链接器看来就是不一样的函数，最开始的时候是没有符号修饰的而是直接使用函数名字在目标文件中表示不同函数的，但是随着语言增加各种特性，再这样的话很容易造成符号冲突，而符号修饰在函数名上加上了命名空间和参数列表等信息，就可以使同名函数不冲突， 且允许函数重载机制。

1. 函数定义和声明不一致

　　　一般写代码时都是分离式编程，即头文件写函数的接口声明，源文件写函数的定义，但是如果我们在

2. C和C++混合编程
3. 编译器版本或编译器选项不一致
4. 把模板函数写进了cpp文件中
5. API hidden
