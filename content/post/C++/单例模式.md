---
title: "单例模式"
date: 2020-07-29T17:36:17+08:00
categories:
- C++
tags:
- 单例模式
keywords:
- tech
#thumbnailImage: //example.com/image.jpg
---
[参考链接](https://segmentfault.com/a/1190000015950693)
<!--more-->
# 单例模式
## 1 什么是单例模式
　　单例模式指在整个系统的生命周期里，一个类只能有一个实例，确保该类的唯一性。

## 2 单例模式分类
　　单例模式分为**懒汉式**和**饿汉式**，这两者的区别在于**创建实例的时间不同**。
- 懒汉式：系统运行中，实例并不存在，只有当需要使用该实例时，才会去创建并使用实例。（需要考虑线程安全）
- 饿汉式：系统一运行，就初始化创建实例，需要时直接调用即可。（本身就线程安全，没有多线程的问题）

## 3 单例类的特点
- 构造函数和析构函数为`private`类型，目的是禁止外部构造和析构
- 拷贝构造函数和赋值构造函数为`private`类型，目的是禁止外部拷贝和赋值，确保实例唯一性
- 类里有个获取实例的`静态函数`，可以全局访问

## 4 应用场景举例
- Windows的任务管理器是很典型的单例模式，不能同时打开两个任务管理器，回收站也是如此
- 应用程序的日志应用，一般可以用单例模式实现，只能有一个实例取操作文件
- 读取配置文件，配置信息只需要读取一次，所有地方都可以用
- 多线程线程池

## 5.1 线程不安全的懒汉模式

```cpp
class Singleton {
 public:
  static Singleton *Instance() {
    //检查对象是否存在
    if (m_instance == nullptr) {
      m_instance = new Singleton();
    }
    return m_instance;
  }

 private:
  Singleton();  //私有构造函数，不允许使用者外部调用
  Singleton(const Singleton &other);
  static Singleton *m_instance;  //静态成员变量
};

Singleton *Singleton::m_instance =
    nullptr;  //静态成员在类内声明，在类外定义与初始化
```

　　这是单例模式最经典的实现方式，将构造函数和拷贝构造函数都设为私有的，且采用了懒汉模式，为什么不是线程安全的呢？

　　正常情况下，若线程A调用Instance()时，将m_instance初始化了，线程B再调用Instance()时，就不会再new了，直接返回已经构造好的对象；但是存在这样一种情况：线程A执行new过程还没结束，此时m_instance仍然为nullptr，因此线程B也会执行new过程，这样就会产生两个对象。

## 5.2 线程安全的懒汉模式（锁的代价过高）

```cpp
static Singleton *Instance() {
  Lock lock;  //伪代码
  if (m_instance == nullptr) {
    m_instance = new Singleton();
  }
  return m_instance;
}
```

　　这种写法不会出现5.1两个线程都new的情况，因为当线程A在new的时候，若线程B在调用Instance()时会被阻塞在加锁处，等待线程A执行结束并释放锁后再继续执行。

　　但这种写法性能不高，因为每次调用Instance()时都会加锁和释放锁，实际上这个步骤只需要在第一次new的时候才是必要的，只要m_instance被创建后，不管多少线程同时访问，if判断已经足够了，锁会影响性能。

## 5.3 双检查锁懒汉模式[内存读写reorder导致的不安全]
　　5.2的写法在某个线程访问时不管三七二十一先加一把锁，这样会导致不必要的锁消耗，那么，是否可以先进行if判断呢，如果m_instance为nullptr，根本不需要加锁，这就是双检查锁(DCL-double check locking)的思想。

```cpp
static Singleton *Instance() {
  //先判断是否已经初始化
  if (m_instance == nullptr) {
    Lock lock;  //伪代码
    if (m_instance == nullptr) {
      m_instance = new Singleton();
    }
  }
  return m_instance;
}
```
　　这种写法看起来很好，而且确实使用了很长时间，但是一段时间后很多人在不同的语言下都发现了漏洞，原因是内存读写乱序执行。`m_instance = new Singleton()`这句话的执行可以表示为下面三个步骤：
1. 分配Singleton类对象需要的内存
2. 在分配的内存处构造Singleton类型对象
3. 把分配的内存地址赋值给m_instance

　　这三个步骤实际上并不是按照固定顺序执行的，能确定的只有第一步是最先执行的，步骤2和步骤3不一定谁先执行，这会导致如下问题：若线程A在执行`m_instance = new Singleton()`的时候是按照1、3、2的顺序，那么刚刚执行完步骤3的时候m_instance已经不是nullptr了，而恰好在此时切到了线程B，那么线程B会直接执行`return m_instance`得到一个还没有被构造的对象，严重bug产生！！！
