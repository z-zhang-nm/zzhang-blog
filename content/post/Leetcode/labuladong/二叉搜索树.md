---
title: "二叉搜索树"
date: 2021-04-26T09:24:05+08:00
categories:
- Leetcode
- labuladong
tags:
- 二叉搜索树
keywords:
- tech
#thumbnailImage: //example.com/image.jpg
---
　　基于BST的数据结构有AVL树、红黑树等，拥有了自平衡性质就可以提供`logN` 级别的增删查改效率
<!--more-->
BST特性：
1. 对于BST的每一个节点`node`，左子树节点的值都比`node`的值要小，右子树节点的值都比`node`的值大
2. 对于BST的每一个节点`node`，它的左侧子树和右侧子树都是BST
3. BST的中序遍历结果是有序的（升序）

# 实例
## 1. 二叉搜索树中第K小的元素
> 找到二叉搜索树中第k个最小元素（k从1开始计数）

```cpp
int kthSmallest(TreeNode* root, int k) {
    if (root == nullptr || k <= 0) return -1;
    vector<int> vals;
    helper(root, vals);
    if (k > vals.size()) return -1;
    return vals[k-1];
}
void helper(TreeNode *root, vector<int> &vals) {
    if (root == nullptr) return;
    helper(root->left, vals);
    vals.push_back(root->val);
    helper(root->right, vals);
}
```

## 2. 把二叉搜索树转换为累加树
> 给出二叉搜索树的根节点，该树的节点值各不相同，请你将其转换为累加树，使每个节点的新值等于原树中大于或等于原节点值之和

> 常规正向中序遍历方法

```cpp
TreeNode* convertBST(TreeNode* root) {
    if (root == nullptr) return nullptr;
    vector<int> vals;
    getRootVals(root, vals);
    for (int i = vals.size()-2; i >=0; --i) {
        vals[i] = vals[i] + vals[i+1];
    }
    int idx = 0;
    setRootVals(root, vals, idx);
    return root;
}
void getRootVals(TreeNode *root, vector<int> &vals) {
    if (root == nullptr) return;
    getRootVals(root->left, vals);
    vals.push_back(root->val);
    getRootVals(root->right, vals);
}
void setRootVals(TreeNode *root, const vector<int> &vals, int &idx) {
    if (root == nullptr) return;
    setRootVals(root->left, vals, idx);
    root->val = vals[idx++];
    setRootVals(root->right, vals, idx);
}
```

> 逆向中序遍历方法

```cpp
class Solution {
    int sum = 0;
public:
    TreeNode* convertBST(TreeNode* root) {
        if (root == nullptr) return nullptr;
        convertBST(root->right);
        sum += root->val;
        root->val = sum;
        convertBST(root->left);
        return root;
    }
};
```

# 3. 验证二叉搜索树
> 给定一个二叉树，判断其是否是一个有效的二叉搜索树

按照以往二叉树的递归思路，很容易写出如下代码：
```cpp
bool isValidBST(TreeNode* root) {
    if(!root) return true;
    if (root->left && root->left->val >= root->val) {
        return false;
    }
    if (root->right && root->right->val <= root->val) {
        return false;
    }
    return isValidBST(root->left) && isValidBST(root->right);
}
```

上面代码是正确的吗？**不是**，因为它只检查了它的左右孩子节点是否符合左小右大的原则，并不能保证节点值大于左子树所有的节点值和小于右子树所有的节点值。

对于一个节点，它只管得了自己的左右孩子节点，那么怎么把节点值的约束传递给左右子树呢？**增加函数参数列表，在参数中携带额外信息，将约束传递给子树的所有节点**。

```cpp
bool isValidBST(TreeNode* root) {
    return isValidBST(root, LONG_MIN, LONG_MAX);
}
bool isValidBST(TreeNode* root, long mn, long mx) {
    if (!root) return true;
    if (root->val <= mn || root->val >= mx) return false;
    return isValidBST(root->left, mn, root->val) && isValidBST(root->right, root->val, mx);
}
```
用`long`代替`int`是为了包括`int`的边界条件。

中序遍历过程中判断：
```cpp
bool isValidBST(TreeNode* root) {
    TreeNode *pre = NULL;
    return inorder(root, pre);
}
bool inorder(TreeNode* node, TreeNode*& pre) {
    if (!node) return true;
    bool res = inorder(node->left, pre);
    if (!res) return false;
    if (pre) {
        if (node->val <= pre->val) return false;
    }
    pre = node;
    return inorder(node->right, pre);
}
```

# 4. 二叉搜索树中的搜索
> 给定二叉搜索树的根节点和一个值，在BST中找到节点值等于给定值的节点，返回以该节点为根的子树，如果节点不存在则返回NULL


