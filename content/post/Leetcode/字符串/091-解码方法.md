---
title: "091 解码方法"
date: 2020-09-25T17:55:08+08:00
categories:
- Leetcode
- 字符串
tags:
- 动态规划
keywords:
- tech
#thumbnailImage: //example.com/image.jpg
---
[题目链接](https://leetcode-cn.com/problems/decode-ways/)
<!--more-->
## 题目
　　一条包含字母 A-Z 的消息通过以下方式进行了编码：
```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```

　　给定一个只包含数字的非空字符串，请计算解码方法的总数。

　　示例：
> 输入: "226"  
输出: 3  
解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6)

## 题解
　　用dp[i]表示s中前i个字符组成的解码方法的个数，将dp[0]初始化为1，下面找状态转移方程。

　　若当前数字为0，那么其不能解码为有效数字，若不是0，则可以解码为有效数字，且对于dp[i-1]种解码方法，都可以加上这个数字解码出来的数字组成有效解码方法，然后再看前一位数字，若其与当前数字组成的数字能有效解码，那么对于dp[i-2]种解码方法，都可以加上这两位数字解码出来的数字组成有效解码方法，前两位数字就不用看了，因为最大只能为26。

　　可以发现，最终的状态转移方程为`dp[i] = dp[i-1] + dp[i-2]`，即斐波那契额数列。

```cpp
int numDecodings(string s) {
    if(s.empty() || s[0] == '0') return 0;
    vector<int> dp(s.size()+1, 0);
    dp[0] = 1;
    for(int i = 1; i <= s.size(); ++i){
        dp[i] = (s[i-1] == '0') ? 0 : dp[i-1];
        if(i > 1 && (s[i-2] == '1' || (s[i-2] == '2' && s[i-1] <= '6'))){
            dp[i] += dp[i-2];
        }
    }
    return dp[s.size()];
}
```
