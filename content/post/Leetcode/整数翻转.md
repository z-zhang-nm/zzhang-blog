---
title: "整数翻转"
date: 2020-06-18T18:49:02+08:00
categories:
- Leetcode
tags:
- 数学
keywords:
- tech
#thumbnailImage: //example.com/image.jpg
---

<!--more-->
## 题目
　　给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

　　示例1：
> 输入: `123`  
> 输出: `321`

　　示例2：
> 输入: `-123`  
> 输出: `-321`

　　示例3：
> 输入: `120`  
> 输出: `21`

　　注意：
　　假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为`[−2^31,  2^31 − 1]`。请根据这个假设，如果反转后整数溢出那么就返回 0。

## 题解一
　　对原数字不断取余并除以10得到逆序的每一个数字，然后不断乘以10加上余数即可对原数字取反，但是要注意在反转的过程中可能会溢出`int`的范围，比如1000000009翻转后得到9000000001，超过了范围，因此需要用`long int`类型。

　　注意`python`中负数取余与`c++`中不太一样。

```cpp
int reverse(int x) {
    long int ret = 0;
    while(x != 0) {
        int curr_num = x % 10;
        ret = ret * 10 + curr_num;
        if ( ret > pow(2, 31) -1 || ret < -1 * pow(2, 31)) {
            return 0;
        }
        x /= 10;
    }
    return ret;
}
```
## 题解二
　　还有一种方法可以不借助`long int`类型，即在更新ret之前首先进行溢出检查，但是检查条件不太一样：在更新ret之前检查ret是否大于214748364（即`INT_MAX / 10`）或小于-214748364。

　　当ret等于214748364的时候，若下一个数字为大于7的数，就会超出范围，但是为什么不用进行检查呢？

　　因为：**`int`类型的范围为`[-2147483648, 2147483647]`，当输入x为最大长度时，第一位只能是1或2，因此翻转之后最后一位也只能是1或2，ret只能是2147483641或2147483642，对应的x为1463847412和2463847412，输入的x也是一个`int`型变量，2463847412超出了范围，因此当ret等于214748364时，输入的x只能是1463847412， 翻转后的结果2147483641在`int`范围内。**

　　这种方法不用分开判断是否超过最大最小整数，因为取绝对值后`INT_MAX / 10`都为214748364。

```cpp
int reverse(int x) {
    int ret = 0;
    while (x != 0) {
        if (abs(ret) > INT_MAX / 10) return 0;
        ret = ret * 10 + x % 10;
        x /= 10;
    }
    return res;
}
```
