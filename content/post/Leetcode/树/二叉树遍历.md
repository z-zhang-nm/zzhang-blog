---
title: "二叉树遍历"
date: 2020-10-12T10:12:47+08:00
categories:
- Leetcode
- 树
tags:
- 二叉树遍历
keywords:
- tech
#thumbnailImage: //example.com/image.jpg
---
[参考链接](https://www.cnblogs.com/songwenjie/p/8955856.html)
<!--more-->
## 什么是二叉树遍历
　　二叉树遍历指的是从把树的所有结点按照某种顺序依次访问一遍，使得每个结点被访问依次且仅被访问一次。

　　根结点定义：
```cpp
struct TreeNode{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
}
```

## 前序遍历
　　`根 -> 左 -> 右`，一般若想在节点上直接执行操作，会使用前序遍历。

### 递归方式
```cpp
void pre_order(TreeNode *root){
    if(root == nullptr) return;
    cout << root->val << endl; //打印val
    pre_order(root->left) //遍历左子树
    pre_order(root->right) //遍历右子树
}
```

### 非递归方式
1. 申请一个栈stack
2. 将根结点压入栈
3. 每次弹出栈顶结点，若其右孩子不为空，将右孩子压入栈，若左孩子不为空，将左孩子压入栈
4. 重复步骤3，直到栈为空

```cpp
void pre_order(TreeNode *root){
    if(root == nullptr) return;
    stack<TreeNode *> stk;
    stk.push(root);
    while(!stk.empty()){
        TreeNode *p = stk.top();
        stk.pop();
        cout << p->val << endl;
        if(p->right != nullptr) stk.push(p->right);
        if(p->left != nullptr) stk.push(p->left);
    }
}
```