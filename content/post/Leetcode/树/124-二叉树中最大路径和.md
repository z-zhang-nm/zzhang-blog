---
title: "124 二叉树中最大路径和"
date: 2020-11-11T10:20:22+08:00
categories:
- Leetcode
tags:
- 树
- 深度优先搜索
keywords:
- tech
#thumbnailImage: //example.com/image.jpg
---
[题目链接](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)
<!--more-->
## 题目
　　给定一个非空二叉树，返回其最大路径和。本题中，路径被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。

　　示例：
```
输入：[-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

输出：42
```

## 题解
　　由一个例子说起：
```
    4
   / \
  11 13
 / \
7   2
```
　　树的递归解法一般都是递归到叶节点，然后开始边处理边回溯到根节点，这里就假设此时已经递归到结点7了，其没有左右子节点，如果以结点7为根结点的子树最大路径和就是7，然后回溯到结点 11，如果以结点 11 为根结点的子树，最大路径和为 7+11+2=20，但是当回溯到结点4的时候，对于结点 11 来说，就不能同时取两条路径了，只能取左路径，或者是右路径，所以当根结点是4的时候，那么结点 11 只能取其左子结点7，因为7大于2，所以，对于每个结点来说，要知道经过其左子结点的 path 之和大还是经过右子节点的 path 之和大，即递归函数返回值就可以定义为以当前结点为根结点，到叶节点的最大路径之和。

　　递归过程中更新**最大完整路径**，递归函数中，如果当前结点不存在，直接返回0，然后分别对其左右子节点调用递归函数，由于路径和有可能为负数，这里当然不希望加上负的路径和，所以和0相比，取较大的那个，就是要么不加，加就要加正数，接下来更新全局最大完整路径，即以左子结点为终点的最大 path 之和加上以右子结点为终点的最大 path 之和，还要加上当前结点值，这样就组成了一个条完整的路径。

　　注意返回值是取 left 和 right 中的较大值加上当前结点值，因为返回值的定义是以当前结点为终点的 path 之和，所以只能取 left 和 right 中较大的那个值，而不是两个都要。

```cpp
int maxPathSum(TreeNode* root) {
    int ret = INT_MIN;
    helper(root, ret);
    return ret;
}
int helper(TreeNode *p, int &ret){
    if(!p) return 0;
    int left = max(helper(p->left, ret), 0);
    int right = max(helper(p->right, ret), 0);
    ret = max(ret, left+right+p->val);
    return max(left, right) + p->val;
}
```
