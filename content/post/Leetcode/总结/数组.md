---
title: "数组"
date: 2020-08-16T09:32:23+08:00
categories:
- Leetcode
- 总结
tags:
- 数组
keywords:
- tech
#thumbnailImage: //example.com/image.jpg
---
　　刷题目标第一阶段(Leetcode前100题)--数组部分完成
<!--more-->
# 概述
　　数组部分以工作日一日一题的速度做了一遍，历时一个半月，平均做题时间三四十分钟，还是有点儿慢的，不过毕竟是第一遍，不能求快，第二遍的时候不仅要保证解法的正确性，速度也要适当提高下。现在对数组做一个小结。

　　下面一大段都是题解，若需要直接看总结内容，跳转到[总结](#总结)即可。

# 题解
　　由于时间间隔太久，有些题目印象已经不是很深了，所以从头开始做一遍先。

## 001-两数之和
　　[本题](https://z-zhang.gitee.io/zzhang-blog/2020/05/001-两数之和/)与N数之和的结果不一样，本题只需要找到一对满足条件的结果即可，不需要找到全部，因此找到一组直接返回即可，但是注意本题的返回结果是**数组元素下标，不能对数组排序，否则会打乱下标**。

　　还有一种解法是使用哈希map记录数组中每个数的下标，因为哈希map的查找效率为常数级，然后从前往后遍历数组，在哈希map中查找是否有剩余值，若找到结果返回下标即可。通常会比较容易想到使用两次循环，第一次更新哈希map记录素组元素下标，第二次寻找返回结果，但是其实使用一次循环即可，每次遍历一个数更新一次haximap，对正确结果，遇到第一个数时，第二个数还不在哈希map中，此时会更新哈希map，遇到第二个数时第一个数已经在map中，因此可以得到正确结果。
```cpp
vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int,int> map;
    for(int i = 0; i < nums.size(); ++i){
        if(map.count(target-nums[i])){
            return {i, map[target-nums[i]]};
        }
        map[nums[i]] = i;
    }
    return {};
}
```

## 004-寻找两个正序数组的中位数
　　[004-寻找两个正序数组的中位数](https://z-zhang.gitee.io/zzhang-blog/2020/06/004-寻找两个正序数组的中位数/)有两种解法，一种解法是在两个数组中找到中位数的位置。

### 解法一
　　若两个数组长度总和为奇数，那么中位数就是最中间的那个，如果是偶数，那么中位数就是最中间的两个数的平均数，这样就需要分两种情况讨论，其实这里有一个小trick，即找到第`(m+n+1)/2`个和第`(m+n+2)/2`个数，求其平均值即可，对于奇数，这两个数其实是一个数。

　　既然要寻找第`(m+n+1)/2`个和第`(m+n+2)/2`个数，那么就需要定义一个寻找两个有序数组中第K个元素的函数，时间复杂度要求`O(log n)`，那么就需要使用二分法，由于是两个数组，那么就需要对两个数组进行二分，分别在两个数组中寻找第`K/2`个元素，若第一个数组的第`K/2`个元素小于第二个数组的第`K/2`个元素，那么丢弃掉第一个数组的前`K/2`个元素，因为这几个数一定在第K个元素之前，同时将第一个数组的起始位置向后移动`K/2`个并将K减去`K/2`，继续递归寻找即可。

　　有如下几种corner case：
1. 某一个数组中已经没有可用元素，即其起始位置大于等于数组长度，那么递归就可以结束，同时直接返回另一个数组中第K个元素即可
2. 若`K==1`，即需要寻找第一个元素，那么递归就可以结束，因为结果一定是两个数组的起始位置的两个数中的其中一个，返回这两个数中较小的那个即可
3. 若某一个数组中没有第`K/2`个元素，那么直接淘汰另一个数组中的前`K/2`个元素即可，可能不太好理解，举个栗子，假设`nums1=[3], nums2=[2,4,5,6,7，8]`，那么`K=4`，分别在两个数组中寻找第二个数字，而第一个数组只有一个数字，那么第二个数组的前两个元素可以直接跳过，为啥呢，因为不管第一个数组中那个数是大是小，第二个数组的前`K/2`个元素一定在第K个元素之前；这种情况下直接将第一个数组的第`K/2`个元素赋值为整型最大值即可

## 015, 018-N数之和
　　[015-三数之和](https://z-zhang.gitee.io/zzhang-blog/2020/06/015-三数之和/)及[018-四数之和](https://z-zhang.gitee.io/zzhang-blog/2020/06/018-四数之和/)属于同一类题，**Nsum**，本质上都是两数之和，只不过是在两数之和外层嵌套了壳子而已，这类题目解法为：
1. 对原数组排序
2. 递归求解，递归结束条件为N等于2，即Two Sum
3. Two Sum使用双指针进行搜索，若两数之和大于目标值，右指针左移，若两数之和小于目标值，左指针右移
4. 由于返回结果中不能有重复的数组，因此遇到重复数字时需要跳过(注意有两个地方需要跳过)

　　代码模板：
```cpp
vector<vector<int>> fourSum(vector<int>& nums, int target) {
  if(nums.size() < N) return {};
  //1. 对原数组排序
  sort(nums.begin(), nums.end());
  //2. 递归求解，递归结束条件为N等于2，即Two Sum
  return FindNSum(nums, target, 0, N);
}

vector<vector<int>> FindNSum(vector<int> &nums, int target, int idx, int N){
  vector<vector<int>> ret;
  //3. Two Sum使用双指针进行搜索，若两数之和大于目标值，右指针左移，若两数之和小于目标值，左指针右移
  if(N == 2){
      int left = idx, right = nums.size()-1;
      while(left < right){
          int curr_sum = nums[left] + nums[right];
          if(curr_sum == target){
              ret.push_back({nums[left], nums[right]});
              //4. 由于返回结果中不能有重复的数组，因此遇到重复数字时需要跳过
              //注意这里也需要满足循环不变量: left < right
              while(left < right && nums[left] == nums[left+1]) left++;
              while(left < right && nums[right] == nums[right-1]) right--;
              left++;
              right--;
          }else if(curr_sum > target){
              right--;
          }else{
              left++;
          }
      }
  }else{
    for(int i = idx; i < nums.size()-N+1; ++i) {
        //4. 由于返回结果中不能有重复的数组，因此遇到重复数字时需要跳过
        if(i > idx && nums[i] == nums[i-1]) continue;
        vector<vector<int>> tmp = FindNSum(nums, target-nums[i], i+1, N-1);
        for(auto &vec : tmp){
            vec.insert(vec.begin(), nums[i]);
            ret.push_back(vec);
        }
    }
  }
  return ret;
}
```
　
## 016-最接近的三数之和
　　[016-最接近的三数之和](https://z-zhang.gitee.io/zzhang-blog/2020/06/016-最接近的三数之和/)属于N数之和的变种，本质上还是N数之和的解题思路，只是需要用一个变量去记录当前与target的最小距离，且本题不是寻找所有满足条件的结果，因此不需要使用递归解法。
```cpp
int threeSumClosest(vector<int>& nums, int target) {
  sort(nums.begin(), nums.end());
  int min_sum = nums[0] + nums[1] + nums[2];
  int min_dis = abs(target-min_sum);
  for(int i = 0; i < nums.size()-3+1; ++i){
      int left = i+1, right = nums.size()-1;
      while(left < right) {
          int curr_sum = nums[left] + nums[right] + nums[i];
          int curr_dis = abs(target - curr_sum);
          if(curr_dis < min_dis){
              min_dis = curr_dis;
              min_sum = curr_sum;
          }
          if (curr_sum < target){
              left++;
          }else{
              right--;
          }
      }
  }
  return min_sum;
}
```
　
# 总结
1. **数组中寻找两数之和为目标值**，固定一个数，查找另一个数，利用哈希的常数查找特性（[**哈希**常数查找特性](#001-两数之和)）
2. **数组中寻找N数之和为目标值**，递归转化为在正序数组中寻找两数之和为目标值，根据左右指针数之和与目标值的关系更新左右指针已更靠近目标值（[**左右指针**在正序数组寻找两数之和](#015-018-n数之和)）
3. **数组中寻找与目标值最接近的N数之和**，本质上是正序数组寻找两数之和，在其外面嵌套循环即可，在靠近目标值的过程中更新当前最小差值（[**左右指针**在正序数组寻找最接近的两数之和](#016-最接近的三数之和)）