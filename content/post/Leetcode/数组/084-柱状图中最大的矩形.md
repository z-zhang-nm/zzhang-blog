---
title: "084 柱状图中最大的矩形"
date: 2020-08-11T10:00:37+08:00
categories:
- Leetcode
- 数组
tags:
- 数组
keywords:
- tech
#thumbnailImage: //example.com/image.jpg
---
[题目链接](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)
<!--more-->
## 题目
　　给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。

　　示例：
> 输入: [2,1,5,6,2,3]  
> 输出: 10

## 题解一
　　看到本题第一反应是与**042-接雨水**一题类似，因此沿用那一题的思路，对每一个柱子，向左右寻找能到达的最远边界，边界的判断准则是柱子高度小于当前柱子高度，则停止，计算当前柱子能勾勒出的最大面积。

　　这种方法可以通过样例，但是提交后对于长度过长的数组会超出时间限制，因为其时间复杂度为`O(N^2)`。

```cpp
int largestRectangleArea(vector<int>& heights) {
    int max_area = 0;
    for(int i = 0; i < heights.size(); ++i) {
        int left = i, right = i;
        while(left >=0 && heights[left] >= heights[i]) left--;
        while(right < heights.size() && heights[right] >= heights[i]) right++;
        int curr_area = (right-left-1) * heights[i];
        if(curr_area > max_area) max_area=curr_area;
    }
    return max_area;
}
```

## 题解二
　　**单调栈**

　　首先归纳下题解一的主要思路：
1. 遍历每一根柱子`h=heights[i]`
2. 对每一根柱子向左右两边扩展，使得扩展到的柱子高度均不小于h
3. 更新最大面积

　　上面的思路可以总结出：如果有两根柱子j0和j1，其中j0在j1的左侧，且j0的高度大于等于j1，那么j1后面的柱子i在向左寻找高度小于heights[i]的柱子时，一定不会找到j0，因为如果j0小于heights[i]，那么在找到j1时已经停止，即j1**挡住了**j0。

　　这样，我们可以对数组从左到右进行遍历，同时维护一个**可能作为答案**的数据结构，其中按照位置从左到右，高度从小到大的顺序存放一些j值，假设我们存放了`j0,j1...j8`，那么一定有`heights[j0]<height[j1]<...<heights[j8]`，因为若相邻的两个j若为`>=`的关系，那么后一个会**挡住**前一个，前一个就不能作为**可能的答案**了。

　　当我们遍历到第i根柱子时，数据机构中已经存放了`j0,j1...j8`，若`heights[j0]<heights[j1]<...<heights[j4]<heights[i]<=heights[j5]<...<heights[8]`，那么就可以将高度大于等于`heights[i]`的j全部移除，剩下的j中最大的即为位置i的柱子的左边界。

　　从上面的分析可以看出，使用的数据结构为栈。

　　总结下要点：
1. 栈中存放了j值，从栈底到栈顶，j值严格单调递增，同时对应的柱子高度也严格单调递增
2. 当遍历到第i根柱子的时候，从栈顶不断移除大于等于当前高度的j值，移除完毕后，栈顶的j值即为i左侧且最近的小于其高度的柱子
   - 这里
3. 将ｉ放入栈顶